// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.4
// source: im.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ImClient is the client API for Im service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ImClient interface {
	// 发送普通文字消息
	SendTextMsg(ctx context.Context, in *SendTextMsgReq, opts ...grpc.CallOption) (*SendTextMsgResp, error)
	// 发送自定义消息
	SendDefineMsg(ctx context.Context, in *SendDefineMsgReq, opts ...grpc.CallOption) (*SendDefineMsgResp, error)
	// 发送小程序订阅消息
	SendMiniProgramSubscribeMsg(ctx context.Context, in *SendMiniProgramSubscribeMsgReq, opts ...grpc.CallOption) (*SendMiniProgramSubscribeMsgResp, error)
	// 发送微信服务号消息
	SendFwhTemplateMsg(ctx context.Context, in *SendFwhTemplateMsgReq, opts ...grpc.CallOption) (*SendFwhTemplateMsgResp, error)
	// 根据用户的服务号openid获取用户的unionId
	GetUserUnionIdByFwhOpenId(ctx context.Context, in *GetUserUnionIdByFwhOpenIdReq, opts ...grpc.CallOption) (*GetUserUnionIdByFwhOpenIdResp, error)
	// 生成小程序url link/schema
	GenWxMpUrl(ctx context.Context, in *GenWxMpUrlReq, opts ...grpc.CallOption) (*GenWxMpUrlResp, error)
	// im msg log
	AddImMsgLog(ctx context.Context, in *AddImMsgLogReq, opts ...grpc.CallOption) (*AddImMsgLogResp, error)
}

type imClient struct {
	cc grpc.ClientConnInterface
}

func NewImClient(cc grpc.ClientConnInterface) ImClient {
	return &imClient{cc}
}

func (c *imClient) SendTextMsg(ctx context.Context, in *SendTextMsgReq, opts ...grpc.CallOption) (*SendTextMsgResp, error) {
	out := new(SendTextMsgResp)
	err := c.cc.Invoke(ctx, "/pb.im/sendTextMsg", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imClient) SendDefineMsg(ctx context.Context, in *SendDefineMsgReq, opts ...grpc.CallOption) (*SendDefineMsgResp, error) {
	out := new(SendDefineMsgResp)
	err := c.cc.Invoke(ctx, "/pb.im/sendDefineMsg", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imClient) SendMiniProgramSubscribeMsg(ctx context.Context, in *SendMiniProgramSubscribeMsgReq, opts ...grpc.CallOption) (*SendMiniProgramSubscribeMsgResp, error) {
	out := new(SendMiniProgramSubscribeMsgResp)
	err := c.cc.Invoke(ctx, "/pb.im/sendMiniProgramSubscribeMsg", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imClient) SendFwhTemplateMsg(ctx context.Context, in *SendFwhTemplateMsgReq, opts ...grpc.CallOption) (*SendFwhTemplateMsgResp, error) {
	out := new(SendFwhTemplateMsgResp)
	err := c.cc.Invoke(ctx, "/pb.im/sendFwhTemplateMsg", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imClient) GetUserUnionIdByFwhOpenId(ctx context.Context, in *GetUserUnionIdByFwhOpenIdReq, opts ...grpc.CallOption) (*GetUserUnionIdByFwhOpenIdResp, error) {
	out := new(GetUserUnionIdByFwhOpenIdResp)
	err := c.cc.Invoke(ctx, "/pb.im/getUserUnionIdByFwhOpenId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imClient) GenWxMpUrl(ctx context.Context, in *GenWxMpUrlReq, opts ...grpc.CallOption) (*GenWxMpUrlResp, error) {
	out := new(GenWxMpUrlResp)
	err := c.cc.Invoke(ctx, "/pb.im/GenWxMpUrl", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imClient) AddImMsgLog(ctx context.Context, in *AddImMsgLogReq, opts ...grpc.CallOption) (*AddImMsgLogResp, error) {
	out := new(AddImMsgLogResp)
	err := c.cc.Invoke(ctx, "/pb.im/AddImMsgLog", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ImServer is the server API for Im service.
// All implementations must embed UnimplementedImServer
// for forward compatibility
type ImServer interface {
	// 发送普通文字消息
	SendTextMsg(context.Context, *SendTextMsgReq) (*SendTextMsgResp, error)
	// 发送自定义消息
	SendDefineMsg(context.Context, *SendDefineMsgReq) (*SendDefineMsgResp, error)
	// 发送小程序订阅消息
	SendMiniProgramSubscribeMsg(context.Context, *SendMiniProgramSubscribeMsgReq) (*SendMiniProgramSubscribeMsgResp, error)
	// 发送微信服务号消息
	SendFwhTemplateMsg(context.Context, *SendFwhTemplateMsgReq) (*SendFwhTemplateMsgResp, error)
	// 根据用户的服务号openid获取用户的unionId
	GetUserUnionIdByFwhOpenId(context.Context, *GetUserUnionIdByFwhOpenIdReq) (*GetUserUnionIdByFwhOpenIdResp, error)
	// 生成小程序url link/schema
	GenWxMpUrl(context.Context, *GenWxMpUrlReq) (*GenWxMpUrlResp, error)
	// im msg log
	AddImMsgLog(context.Context, *AddImMsgLogReq) (*AddImMsgLogResp, error)
	mustEmbedUnimplementedImServer()
}

// UnimplementedImServer must be embedded to have forward compatible implementations.
type UnimplementedImServer struct {
}

func (UnimplementedImServer) SendTextMsg(context.Context, *SendTextMsgReq) (*SendTextMsgResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendTextMsg not implemented")
}
func (UnimplementedImServer) SendDefineMsg(context.Context, *SendDefineMsgReq) (*SendDefineMsgResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendDefineMsg not implemented")
}
func (UnimplementedImServer) SendMiniProgramSubscribeMsg(context.Context, *SendMiniProgramSubscribeMsgReq) (*SendMiniProgramSubscribeMsgResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendMiniProgramSubscribeMsg not implemented")
}
func (UnimplementedImServer) SendFwhTemplateMsg(context.Context, *SendFwhTemplateMsgReq) (*SendFwhTemplateMsgResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendFwhTemplateMsg not implemented")
}
func (UnimplementedImServer) GetUserUnionIdByFwhOpenId(context.Context, *GetUserUnionIdByFwhOpenIdReq) (*GetUserUnionIdByFwhOpenIdResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserUnionIdByFwhOpenId not implemented")
}
func (UnimplementedImServer) GenWxMpUrl(context.Context, *GenWxMpUrlReq) (*GenWxMpUrlResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenWxMpUrl not implemented")
}
func (UnimplementedImServer) AddImMsgLog(context.Context, *AddImMsgLogReq) (*AddImMsgLogResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddImMsgLog not implemented")
}
func (UnimplementedImServer) mustEmbedUnimplementedImServer() {}

// UnsafeImServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ImServer will
// result in compilation errors.
type UnsafeImServer interface {
	mustEmbedUnimplementedImServer()
}

func RegisterImServer(s grpc.ServiceRegistrar, srv ImServer) {
	s.RegisterService(&Im_ServiceDesc, srv)
}

func _Im_SendTextMsg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendTextMsgReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImServer).SendTextMsg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.im/sendTextMsg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImServer).SendTextMsg(ctx, req.(*SendTextMsgReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Im_SendDefineMsg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendDefineMsgReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImServer).SendDefineMsg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.im/sendDefineMsg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImServer).SendDefineMsg(ctx, req.(*SendDefineMsgReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Im_SendMiniProgramSubscribeMsg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendMiniProgramSubscribeMsgReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImServer).SendMiniProgramSubscribeMsg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.im/sendMiniProgramSubscribeMsg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImServer).SendMiniProgramSubscribeMsg(ctx, req.(*SendMiniProgramSubscribeMsgReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Im_SendFwhTemplateMsg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendFwhTemplateMsgReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImServer).SendFwhTemplateMsg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.im/sendFwhTemplateMsg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImServer).SendFwhTemplateMsg(ctx, req.(*SendFwhTemplateMsgReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Im_GetUserUnionIdByFwhOpenId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserUnionIdByFwhOpenIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImServer).GetUserUnionIdByFwhOpenId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.im/getUserUnionIdByFwhOpenId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImServer).GetUserUnionIdByFwhOpenId(ctx, req.(*GetUserUnionIdByFwhOpenIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Im_GenWxMpUrl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenWxMpUrlReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImServer).GenWxMpUrl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.im/GenWxMpUrl",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImServer).GenWxMpUrl(ctx, req.(*GenWxMpUrlReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Im_AddImMsgLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddImMsgLogReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImServer).AddImMsgLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.im/AddImMsgLog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImServer).AddImMsgLog(ctx, req.(*AddImMsgLogReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Im_ServiceDesc is the grpc.ServiceDesc for Im service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Im_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.im",
	HandlerType: (*ImServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "sendTextMsg",
			Handler:    _Im_SendTextMsg_Handler,
		},
		{
			MethodName: "sendDefineMsg",
			Handler:    _Im_SendDefineMsg_Handler,
		},
		{
			MethodName: "sendMiniProgramSubscribeMsg",
			Handler:    _Im_SendMiniProgramSubscribeMsg_Handler,
		},
		{
			MethodName: "sendFwhTemplateMsg",
			Handler:    _Im_SendFwhTemplateMsg_Handler,
		},
		{
			MethodName: "getUserUnionIdByFwhOpenId",
			Handler:    _Im_GetUserUnionIdByFwhOpenId_Handler,
		},
		{
			MethodName: "GenWxMpUrl",
			Handler:    _Im_GenWxMpUrl_Handler,
		},
		{
			MethodName: "AddImMsgLog",
			Handler:    _Im_AddImMsgLog_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "im.proto",
}
